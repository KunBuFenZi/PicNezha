const express = require("express");
const serverless = require("serverless-http");
const axios = require("axios");
const { createCanvas, registerFont } = require("canvas");
const { Canvas, FontLibrary } = require("skia-canvas");
const moment = require("moment");
const path = require("path");

const app = express();
const port = 3000;

// ÈíàÂØπnetlifyÁöÑÁâπÊÆäËÆæÁΩÆ
let currentDir = __dirname;
if (currentDir.includes(".netlify/functions-serve/app")) {
  var netlify = true;
  console.log("Áé∞Âú®Âú®netlify‰∏≠ËøêË°åÔºåÂΩìÂâçÁõÆÂΩïÔºö" + currentDir);
  currentDir = currentDir.replace(".netlify/functions-serve/app", "");
}
// Ê≥®ÂÜåÂ≠ó‰Ωì
// FontLibrary.use("WQY-ZenHei", __dirname + "/wqy-zenhei.ttc");
FontLibrary.use("WQY-ZenHei", currentDir + "/wqy-zenhei.ttc");
// FontLibrary.use("Noto Color Emoji", __dirname + "/NotoColorEmoji.ttf");
FontLibrary.use("Segoe UI Emoji", currentDir + "/seguiemj.ttf");

// Ê∑ªÂä†ÈÖçÁΩÆÂèòÈáè
const config = {
  SERVERS_PER_ROW: parseInt(process.env.SERVERS_PER_ROW) || 2, // ÊØèË°åÊòæÁ§∫ÊúçÂä°Âô®Êï∞Èáè
  MIN_WIDTH: 350,  // ÊúÄÂ∞èÂÆΩÂ∫¶
  MIN_HEIGHT: 100, // ÊúÄÂ∞èÈ´òÂ∫¶
  PADDING: 10,     // Âç°ÁâáÈó¥Ë∑ù
  TEXT_LINE_HEIGHT: 20 // ÊñáÊú¨Ë°åÈ´ò
};

// Ê∑ªÂä†ÁôªÂΩïËÆ§ËØÅÂáΩÊï∞
async function authenticate(apiUrl, username, password) {
  const response = await axios.post(`${apiUrl}/api/v1/login`, {
    username: username,
    password: password
  });
  
  if (response.data.success) {
    return response.data.data.token;
  }
  throw new Error('ËÆ§ËØÅÂ§±Ë¥•');
}

// Ê∑ªÂä†ËÆ°ÁÆóÊñáÊú¨Â∞∫ÂØ∏ÁöÑÂáΩÊï∞
function measureServerCard(ctx, server) {
  const textLines = [
    `${server.name} ${server.statusText}`,
    `üñ•Ô∏è ${server.host.Platform}`,
    `üìç ${server.host.CountryCode}`,
    `‚è±Ô∏è Uptime: ${moment.duration(server.status.Uptime, "seconds").humanize()}`,
    "üíª CPU:",
    "üß† RAM:",
    "ÊÄª‰∏ãËΩΩ:",
    "ÊÄª‰∏ä‰º†:"
  ];
  
  // ËÆ°ÁÆóÊúÄÂ§ßÊñáÊú¨ÂÆΩÂ∫¶
  let maxWidth = 0;
  textLines.forEach(line => {
    const metrics = ctx.measureText(line);
    maxWidth = Math.max(maxWidth, metrics.width);
  });
  
  // ËÄÉËôëËøõÂ∫¶Êù°ÂíåÊï∞ÂÄºÁöÑÂÆΩÂ∫¶
  const totalWidth = Math.max(maxWidth + 250, config.MIN_WIDTH); // 250px Áî®‰∫éËøõÂ∫¶Êù°ÂíåÂÖ∂‰ªñÂÖÉÁ¥†
  const totalHeight = Math.max(textLines.length * config.TEXT_LINE_HEIGHT, config.MIN_HEIGHT);
  
  return { width: totalWidth, height: totalHeight };
}

// Âú® /status Ë∑ØÁî±‰∏≠‰ΩøÁî®
app.get("/status", async (req, res) => {
  try {
    const apiUrl = process.env.API_URL?.replace(/\/$/, "");
    const token = await authenticate(apiUrl, process.env.USERNAME, process.env.PASSWORD);
    
    const response = await axios.get(`${apiUrl}/api/v1/server`, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    if (!response.data.success) {
      throw new Error(response.data.message || "API request failed");
    }

    // Ëß£ÊûêÊúçÂä°Âô®Êï∞ÊçÆ
    const servers = response.data.data.map(server => ({
      name: server.name || "Êú™Áü•",
      statusText: isOnline(server) ? "‚ùáÔ∏èÂú®Á∫ø" : "‚ùåÁ¶ªÁ∫ø",
      host: {
        Platform: server.host?.platform || "Êú™Áü•",
        PlatformVersion: server.host?.version || "",
        CountryCode: server.geoip?.country_code || "UN",
        MemTotal: server.host?.mem_total || 1,
      },
      status: {
        CPU: server.state?.cpu || 0,
        MemUsed: server.state?.mem_used || 0,
        Uptime: server.state?.uptime || 0,
        NetInTransfer: server.state?.net_in_transfer || 0,
        NetOutTransfer: server.state?.net_out_transfer || 0,
      }
    }));

    // ÂàõÂª∫‰∏¥Êó∂ Canvas Áî®‰∫éÊµãÈáè
    const measureCanvas = new Canvas(1, 1);
    const measureCtx = measureCanvas.getContext('2d');
    measureCtx.font = 'bold 16px "Segoe UI Emoji", "WQY-ZenHei"';

    // È¢ÑÂÖàËÆ°ÁÆóÊØè‰∏™ÊúçÂä°Âô®Âç°ÁâáÁöÑÂ∞∫ÂØ∏
    let maxCardWidth = 0;
    let maxCardHeight = 0;
    
    servers.forEach(server => {
      const dims = measureServerCard(measureCtx, server);
      maxCardWidth = Math.max(maxCardWidth, dims.width);
      maxCardHeight = Math.max(maxCardHeight, dims.height);
    });
    
    // Êõ¥Êñ∞ÈÖçÁΩÆ
    config.SERVER_WIDTH = maxCardWidth + config.PADDING * 2;
    config.SERVER_HEIGHT = maxCardHeight + config.PADDING * 2;
    
    // ËÆ°ÁÆóÁîªÂ∏ÉÂ∞∫ÂØ∏
    const rows = Math.ceil(servers.length / config.SERVERS_PER_ROW);
    const canvasWidth = config.SERVER_WIDTH * config.SERVERS_PER_ROW + config.PADDING * (config.SERVERS_PER_ROW + 1);
    const canvasHeight = config.SERVER_HEIGHT * rows + 90 + config.PADDING * (rows + 1);

    // ÂàõÂª∫ÂÆûÈôÖÁªòÂõæÁî®ÁöÑÁîªÂ∏É
    let canvas = new Canvas(canvasWidth, canvasHeight);
    let ctx = canvas.getContext("2d");
    ctx.textDrawingMode = "glyph";

    // ËÉåÊôØÁ∫ØËâ≤ÔºàÊ≥®ÈáäÊéâ‰ºöÂèòÈÄèÊòéÔºâ
    // ctx.fillStyle = "#ffffff";
    // ctx.fillRect(0, 0, 800, canvas.height);

    // ËÉåÊôØÂç°Áâá
    const cardX = 10;
    const cardY = 10;
    const cardWidth = canvas.width - 20;
    const cardHeight = canvas.height - 20;
    const borderRadius = 16;

    // Èò¥ÂΩ±ËÆæÁΩÆ
    ctx.shadowColor = "rgba(0, 0, 0, 0.2)"; // Èò¥ÂΩ±È¢úËâ≤
    ctx.shadowBlur = 10; // Ê®°Á≥äÁ®ãÂ∫¶

    // 30Â∫¶ËßíÊ∏êÂèò
    const angle = Math.PI / 6;
    const d = (cardHeight - cardWidth * Math.tan(angle)) / 2;
    const startY = cardY + d;
    const endY = cardY + cardHeight - d;

    // ÂàõÂª∫Ê∏êÂèòÈ¢úËâ≤
    const gradient = ctx.createLinearGradient(
      cardX,
      startY,
      cardX + cardWidth,
      endY
    );
    gradient.addColorStop(0, "#f5f9fa");
    gradient.addColorStop(0.5, "#ecf9f6");
    gradient.addColorStop(1, "#f5f9fa");

    // ÁªòÂà∂ÂúÜËßíÂç°Áâá
    ctx.beginPath();
    ctx.moveTo(cardX + borderRadius, cardY);
    ctx.lineTo(cardX + cardWidth - borderRadius, cardY);
    ctx.quadraticCurveTo(
      cardX + cardWidth,
      cardY,
      cardX + cardWidth,
      cardY + borderRadius
    );
    ctx.lineTo(cardX + cardWidth, cardY + cardHeight - borderRadius);
    ctx.quadraticCurveTo(
      cardX + cardWidth,
      cardY + cardHeight,
      cardX + cardWidth - borderRadius,
      cardY + cardHeight
    );
    ctx.lineTo(cardX + borderRadius, cardY + cardHeight);
    ctx.quadraticCurveTo(
      cardX,
      cardY + cardHeight,
      cardX,
      cardY + cardHeight - borderRadius
    );
    ctx.lineTo(cardX, cardY + borderRadius);
    ctx.quadraticCurveTo(cardX, cardY, cardX + borderRadius, cardY);
    ctx.closePath();

    // Â°´ÂÖÖ
    ctx.fillStyle = gradient;
    ctx.fill();

    // ÈáçÁΩÆÈò¥ÂΩ±ÔºàÈò≤Ê≠¢ÂêéÁª≠ÂΩ±ÂìçÔºâ
    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // Âç°Áâá Header
    const headerHeight = 50;
    const headerGradient = ctx.createLinearGradient(
      cardX,
      cardY,
      cardX + cardWidth,
      cardY
    );
    headerGradient.addColorStop(0, "#88FDCD");
    headerGradient.addColorStop(1, "#95C4F5");

    // ÁªòÂà∂ Header Âå∫Âüü
    ctx.beginPath();
    ctx.moveTo(cardX + borderRadius, cardY); // Â∑¶‰∏äËßíÂúÜËßíÂºÄÂßã
    ctx.lineTo(cardX + cardWidth - borderRadius, cardY); // È°∂ËæπÁõ¥Á∫ø
    ctx.quadraticCurveTo(
      cardX + cardWidth,
      cardY,
      cardX + cardWidth,
      cardY + borderRadius
    ); // Âè≥‰∏äËßíÂúÜËßí
    ctx.lineTo(cardX + cardWidth, cardY + headerHeight); // Âè≥‰æßÁõ¥Á∫ø
    ctx.lineTo(cardX, cardY + headerHeight); // Â∫ïËæπÁõ¥Á∫ø
    ctx.lineTo(cardX, cardY + borderRadius); // Â∑¶‰æßÁõ¥Á∫ø
    ctx.quadraticCurveTo(cardX, cardY, cardX + borderRadius, cardY); // Â∑¶‰∏äËßíÂúÜËßí
    ctx.closePath();

    ctx.fillStyle = headerGradient;
    ctx.fill();

    // ÁªòÂà∂ Header ÊñáÊú¨
    const headerText = process.env.TEXT || process.env.API_URL || "Êé¢Èíà";
    ctx.fillStyle = "#000000";
    ctx.font = '20px "Segoe UI Emoji", "WQY-ZenHei", Arial';
    ctx.textBaseline = "middle"; // ÂûÇÁõ¥Â±Ö‰∏≠
    ctx.fillText(headerText, cardX + 20, cardY + headerHeight / 2);
    ctx.textBaseline = "alphabetic"; // ÈáçÁΩÆÊñáÊú¨Âü∫Á∫ø‰∏∫ÂØπÈΩêÂà∞Ê†áÂáÜÂ≠óÊØçÂü∫Á∫ø

    servers.forEach((server, index) => {
      const row = Math.floor(index / config.SERVERS_PER_ROW);
      const col = index % config.SERVERS_PER_ROW;
      
      const x = config.PADDING + col * (config.SERVER_WIDTH + config.PADDING);
      const y = 90 + row * (config.SERVER_HEIGHT + config.PADDING);

      // ÊúçÂä°Âô®ÂêçÁß∞ÂíåÁä∂ÊÄÅ
      ctx.fillStyle = "#000";
      ctx.font = 'bold 16px "Segoe UI Emoji", "WQY-ZenHei"';
      ctx.fillText(`${server.name} ${server.statusText}`, x + 20, y);

      // Á≥ªÁªü‰ø°ÊÅØ
      ctx.font = '14px "Segoe UI Emoji", "WQY-ZenHei", Arial';
      ctx.fillText(
        `üñ•Ô∏è ${server.host.Platform}`,
        x + 20,
        y + 25
      );

      // ÂõΩÂÆ∂
      ctx.fillText(`üìç ${server.host.CountryCode}`, x + 20, y + 45);

      // Uptime
      ctx.fillText(
        `‚è±Ô∏è Uptime: ${moment.duration(server.status.Uptime, "seconds").humanize()}`,
        x + 20,
        y + 65
      );

      // CPU Usage
      ctx.fillText("üíª CPU:", x + 180, y + 25);
      drawProgressBar(ctx, x + 235, y + 12, 120, server.status.CPU);

      // RAM Usage
      ctx.fillText("üß† RAM:", x + 180, y + 55);
      const ramUsage = (server.status.MemUsed / server.host.MemTotal) * 100;
      drawProgressBar(ctx, x + 235, y + 42, 120, ramUsage);

      // ÁΩëÁªúÊµÅÈáè
      ctx.fillText("ÊÄª‰∏ãËΩΩ:", 620, y + 25);
      ctx.fillText(formatBytes(server.status.NetInTransfer), 670, y + 25);

      ctx.fillText("ÊÄª‰∏ä‰º†:", 620, y + 55);
      ctx.fillText(formatBytes(server.status.NetOutTransfer), 670, y + 55);
    });

    ctx.font = "10px Arial";
    ctx.fillStyle = "rgba(0, 0, 0, 0.54)";
    ctx.fillText(
      "Powered By PicNezha (https://github.com/SkyAerope/PicNezha)",
      canvas.width - 350,
      canvas.height - 20
    );

    const buffer = await canvas.toBuffer("image/png");
    res.set("Content-Type", "image/png");
    res.send(buffer);
  } catch (error) {
    console.error("Error:", error);
    // res.status(500).send("Error generating status page: " + error.message);
    let canvas = new Canvas(800, 200),
      ctx = canvas.getContext("2d");

    ctx.fillStyle = "#ffebee"; // ËÉåÊôØÈ¢úËâ≤ÔºöÊµÖÁ∫¢Ëâ≤
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#b71c1c"; // Â≠ó‰ΩìÈ¢úËâ≤ÔºöÊ∑±Á∫¢Ëâ≤
    ctx.font = 'bold 20px "Segoe UI Emoji", "WQY-ZenHei", Arial';
    ctx.fillText("ÁîüÊàêÂõæÁâáÂá∫Èîô", 50, 60);

    ctx.fillStyle = "#000000"; // ÈîôËØØËØ¶ÊÉÖÂ≠ó‰ΩìÈ¢úËâ≤
    ctx.font = '16px "Segoe UI Emoji", "WQY-ZenHei", Arial';

    const lines = wrapText(ctx, error.message, 700);
    lines.forEach((line, index) => {
      ctx.fillText(line, 50, 100 + index * 20);
    });

    const buffer = await canvas.toBuffer("image/png");
    res.set("Content-Type", "image/png");
    res.send(buffer);
  }
});

function isOnline(server) {
  const now = Date.now();
  const lastActive = new Date(server.last_active).getTime();
  return (now - lastActive) < 10000; // 10ÁßíÂÜÖËÆ§‰∏∫Âú®Á∫ø
}

// ÁîªËøõÂ∫¶Êù°
function drawProgressBar(ctx, x, y, width, value) {
  const height = 15;
  const radius = height / 2; // ÂúÜËßíÂçäÂæÑÔºàÈ´òÂ∫¶ÁöÑ‰∏ÄÂçäÔºâ
  const progressWidth = width * (value / 100); // Ê†πÊçÆËøõÂ∫¶ËÆ°ÁÆóÂÆΩÂ∫¶
  // ÂàõÂª∫Ê∏êÂèò
  const gradient = ctx.createLinearGradient(x, y, x + width, y); // Ê∞¥Âπ≥ÊñπÂêëÁöÑÊ∏êÂèò
  gradient.addColorStop(0, "#90c4fc"); // Ëµ∑ÂßãÈ¢úËâ≤ÔºöÊµÖËìùËâ≤
  gradient.addColorStop(1, "#ddc4fc"); // ÁªìÊùüÈ¢úËâ≤ÔºöÊ∑°Á¥´Ëâ≤

  // ËÉåÊôØÊù°
  ctx.fillStyle = "#e5e7eb"; // ËÉåÊôØÈ¢úËâ≤
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + width, y, x + width, y + height, radius);
  ctx.arcTo(x + width, y + height, x, y + height, radius);
  ctx.arcTo(x, y + height, x, y, radius);
  ctx.arcTo(x, y, x + width, y, radius);
  ctx.closePath();
  ctx.fill();

  // ËøõÂ∫¶Êù°
  ctx.fillStyle = gradient;
  ctx.beginPath();
  if (value >= 5) {
    // Ê≠£Â∏∏ÁªòÂà∂ÂúÜËßíÊù°ÂΩ¢
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + progressWidth, y, x + progressWidth, y + height, radius);
    ctx.arcTo(x + progressWidth, y + height, x, y + height, radius);
    ctx.arcTo(x, y + height, x, y, radius);
    ctx.arcTo(x, y, x + progressWidth, y, radius);
  } else {
    // ÁªòÂà∂Â∑¶ËæπÂúÜËßíÔºåÂè≥ËæπÁõ¥ËæπÔºåÊÄé‰πàÁîªËøõÂ∫¶Êù°ËøòË¶ÅÂÅöÊï∞Â≠¶È¢òÂïä
    const cosTheta = (height - progressWidth * 2) / height;
    ctx.moveTo(x, y + radius);
    ctx.arc(
      x + height / 2,
      y + height / 2,
      radius,
      Math.PI,
      Math.PI + Math.acos(cosTheta),
      false
    ); // Â∑¶‰∏äÂúÜËßí
    ctx.lineTo(x + progressWidth, y + height / 2 + progressWidth); // Âè≥Ëæπ
    ctx.arc(
      x + height / 2,
      y + height / 2,
      radius,
      Math.PI - Math.acos(cosTheta),
      Math.PI,
      false
    ); // Â∑¶‰∏ãÂúÜËßí
  }
  ctx.closePath();
  ctx.fill();

  // ÁôæÂàÜÊØîÊñáÂ≠ó
  ctx.fillStyle = "#000000";
  ctx.fillText(Math.round(value) + "%", x + width + 5, y + 12);
}

// Ëá™Âä®Êç¢Ë°å
function wrapText(ctx, text, maxWidth) {
  const words = text.split(" ");
  const lines = [];
  let line = "";

  for (let word of words) {
    const testLine = line + word + " ";
    const metrics = ctx.measureText(testLine);
    const testWidth = metrics.width;

    if (testWidth > maxWidth) {
      lines.push(line.trim());
      line = word + " ";
    } else {
      line = testLine;
    }
  }
  lines.push(line.trim());
  return lines;
}

// ÊµÅÈáèÂçï‰ΩçÊç¢ÁÆó
function formatBytes(bytes) {
  if (bytes === 0) return "0 B";
  const sizes = ["B", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + " " + sizes[i];
}

if (!netlify) {
  app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}/status`);
  });
} else {
  module.exports.handler = serverless(app);
}
